// ==UserScript==
// @name         Canvas | All Courses | Search Bar & Term Filter
// @version      0.0.6
// @description  Filters courses based on user input and term selection in course list page
// @author       Daniel Victoriano <victoriano518@gmail.com> but then Alex took it and used Claude to make some changes. Andy came up with the filtering by term.
// @match        https://*.instructure.com/courses
// @grant        none
// ==/UserScript==

(function() {
  let rows = Array.from(document.querySelectorAll('#content table tbody tr'));
  let header = document.querySelector('.header-bar');

  // Pre-process and cache searchable content
  let rowData = rows.map(row => {
    const termCell = row.querySelector('.course-list-term-column');
    const termText = termCell ? termCell.textContent.trim() : '';

    return {
      element: row,
      searchText: row.textContent.toLowerCase().trim(),
      term: termText,
      isVisible: true
    };
  });

  // Create search input
  let input = document.createElement('input');
  input.setAttribute('type', 'text');
  input.setAttribute('placeholder', 'Search');
  input.setAttribute('style', 'margin-left: 10px; padding: 5px; width: 200px;');

  // Create term filter dropdown
  let termSelect = document.createElement('select');
  termSelect.setAttribute('style', 'margin-left: 10px; padding: 5px;');

  // Collect unique terms
  let uniqueTerms = new Set();
  rowData.forEach(item => {
    if (item.term) {
      uniqueTerms.add(item.term);
    }
  });

  // Sort terms (most recent first, with special handling)
  let termsArray = Array.from(uniqueTerms).sort((a, b) => {
    // Handle special cases
    const specialTerms = ['NULL - Term', 'Non Term Associated', ''];
    if (specialTerms.includes(a) && !specialTerms.includes(b)) return 1;
    if (specialTerms.includes(b) && !specialTerms.includes(a)) return -1;
    if (specialTerms.includes(a) && specialTerms.includes(b)) return 0;

    // Extract the numeric part (e.g., "1261" from "1261 - Spring 2026")
    const getTermNumber = (term) => {
      const match = term.match(/^(\d+)/);
      return match ? parseInt(match[1]) : 0;
    };

    return getTermNumber(b) - getTermNumber(a); // Descending order (newest first)
  });

  // Add "All Terms" option
  let allOption = document.createElement('option');
  allOption.value = '';
  allOption.textContent = 'All Terms';
  termSelect.appendChild(allOption);

  // Add term options
  termsArray.forEach(term => {
    let option = document.createElement('option');
    option.value = term;
    option.textContent = term || '(No Term)';
    termSelect.appendChild(option);
  });

  // Append both controls to header
  header.appendChild(input);
  header.appendChild(termSelect);

  let timeoutId;
  let lastQuery = '';
  let lastTerm = '';

  input.addEventListener('input', function() {
    clearTimeout(timeoutId);
    timeoutId = setTimeout(() => {
      requestAnimationFrame(filterRows);
    }, 150);
  });

  termSelect.addEventListener('change', function() {
    requestAnimationFrame(filterRows);
  });

  function rebuildCache() {
    rowData.forEach(item => {
      item.searchText = item.element.textContent.toLowerCase().trim();
      const termCell = item.element.querySelector('.course-list-term-column');
      item.term = termCell ? termCell.textContent.trim() : '';
    });

    // Rebuild term dropdown options
    let uniqueTerms = new Set();
    rowData.forEach(item => {
      if (item.term) {
        uniqueTerms.add(item.term);
      }
    });

    let termsArray = Array.from(uniqueTerms).sort((a, b) => {
      const specialTerms = ['NULL - Term', 'Non Term Associated', ''];
      if (specialTerms.includes(a) && !specialTerms.includes(b)) return 1;
      if (specialTerms.includes(b) && !specialTerms.includes(a)) return -1;
      if (specialTerms.includes(a) && specialTerms.includes(b)) return 0;

      const getTermNumber = (term) => {
        const match = term.match(/^(\d+)/);
        return match ? parseInt(match[1]) : 0;
      };

      return getTermNumber(b) - getTermNumber(a);
    });

    // Save current selection
    const currentSelection = termSelect.value;

    // Clear and rebuild options
    termSelect.innerHTML = '';
    let allOption = document.createElement('option');
    allOption.value = '';
    allOption.textContent = 'All Terms';
    termSelect.appendChild(allOption);

    termsArray.forEach(term => {
      let option = document.createElement('option');
      option.value = term;
      option.textContent = term || '(No Term)';
      termSelect.appendChild(option);
    });

    // Restore selection if it still exists
    if (termsArray.includes(currentSelection)) {
      termSelect.value = currentSelection;
    }

    // Re-run filter with current query
    if (input.value.trim() !== '' || termSelect.value !== '') {
      filterRows();
    }
  }

  // Watch for teacher names being added
  const observer = new MutationObserver((mutations) => {
    let teacherCellsChanged = false;

    for (const mutation of mutations) {
      // Check if teacher cells were added or modified
      if (mutation.target.classList && mutation.target.classList.contains('teacher-cell')) {
        teacherCellsChanged = true;
        break;
      }
      // Check if any added nodes are teacher cells
      for (const node of mutation.addedNodes) {
        if (node.classList && node.classList.contains('teacher-cell')) {
          teacherCellsChanged = true;
          break;
        }
      }
      if (teacherCellsChanged) break;
    }

    if (teacherCellsChanged) {
      // Debounce cache rebuilds
      clearTimeout(observer.rebuildTimeout);
      observer.rebuildTimeout = setTimeout(rebuildCache, 500);
    }
  });

  // Observe all tables for teacher cell changes
  const tables = document.querySelectorAll('#content table tbody');
  tables.forEach(table => {
    observer.observe(table, {
      childList: true,
      subtree: true,
      characterData: true
    });
  });

  function filterRows() {
    let query = input.value.trim().toLowerCase();
    let selectedTerm = termSelect.value;

    // Skip if nothing has changed
    if (query === lastQuery && selectedTerm === lastTerm) return;
    lastQuery = query;
    lastTerm = selectedTerm;

    // Batch DOM operations for better performance
    let elementsToShow = [];
    let elementsToHide = [];

    // Process in chunks to avoid blocking the main thread
    function processChunk(startIndex) {
      const CHUNK_SIZE = 100;
      const endIndex = Math.min(startIndex + CHUNK_SIZE, rowData.length);

      for (let i = startIndex; i < endIndex; i++) {
        const item = rowData[i];

        // Check both search query and term filter
        const matchesSearch = query === '' || item.searchText.includes(query);
        const matchesTerm = selectedTerm === '' || item.term === selectedTerm;
        const shouldShow = matchesSearch && matchesTerm;

        if (shouldShow !== item.isVisible) {
          item.isVisible = shouldShow;
          if (shouldShow) {
            elementsToShow.push(item.element);
          } else {
            elementsToHide.push(item.element);
          }
        }
      }

      // If there are more items, schedule the next chunk
      if (endIndex < rowData.length) {
        requestAnimationFrame(() => processChunk(endIndex));
      } else {
        // Apply all DOM changes at once
        applyChanges();
      }
    }

    function applyChanges() {
      // Batch show operations
      elementsToShow.forEach(el => {
        el.style.display = '';
      });

      // Batch hide operations
      elementsToHide.forEach(el => {
        el.style.display = 'none';
      });

      // Optional: Update a counter or status
      updateResultsCount();
    }

    function updateResultsCount() {
      // Optional: Show "X of Y courses" somewhere
      const visibleCount = rowData.filter(item => item.isVisible).length;
      console.log(`Showing ${visibleCount} of ${rowData.length} courses`);
    }

    // Start processing
    processChunk(0);
  }

  // Clear search with Escape when focused
  input.addEventListener('keydown', function(e) {
    if (e.key === 'Escape') {
      this.value = '';
      filterRows();
    }
  });

  // Optimization: If user is typing rapidly, increase debounce
  let rapidTypingCount = 0;
  input.addEventListener('input', function() {
    rapidTypingCount++;
    setTimeout(() => rapidTypingCount--, 1000);

    clearTimeout(timeoutId);
    const debounceTime = rapidTypingCount > 5 ? 300 : 150;
    timeoutId = setTimeout(() => {
      requestAnimationFrame(filterRows);
    }, debounceTime);
  });
})();
