// ==UserScript==
// @name        Canvas | Rubrics | Rubric Excel Importer
// @author      James Jones from the Instructure Community, modified by Alex & Claude
// @description Create a rubric by copying from a spreadsheet and pasting into Canvas
// @include     https://*.instructure.com/courses/*/rubrics
// @version     8.4
// @grant       none
// ==/UserScript==
(function() {
  'use strict';
  var assocRegex = new RegExp('^/(course|account)s/([0-9]+)/rubrics$');
  var errors = [];
  var criteria = [];
  var rubricTitle;
  var rubricAssociation;

  if (assocRegex.test(window.location.pathname)) {
    add_button();
  }

  function checkPointsRow(cols) {
    if (typeof cols === 'undefined' || cols.length < 3 || isPoints(cols[0])) {
      return false;
    }
    var points = [];
    var isValid = true;
    var i = 1;
    var firstCol;
    var block = false;
    while (isValid && i < cols.length) {
      var item = cols[i++];
      if (isPoints(item)) {
        points.push(item);
        if (typeof firstCol === 'undefined') {
          firstCol = i - 1;
        }
      } else if (i > 2) {
        isValid = false;
      }
    }
    if (isValid && points.length > 1) {
      var order = checkMonotonic(points, true);
      if (order) {
        block = {
          'order' : order,
          'points' : points,
          'start' : firstCol,
          'end' : firstCol + points.length - 1,
          'columns' : cols.length
        };
        if (typeof checkPointsRow.initial === 'undefined') {
          checkPointsRow.initial = block.start;
        }
      }
    }
    return block;
  }

  function checkMonotonic(A, isStrict) {
    if (typeof A === 'undefined') {
      return 0;
    }
    if (typeof isStrict === 'undefined') {
      isStrict = true;
    }
    var order;
    var isMonotonic = true;
    var a, b;
    a = Number(A[0]);
    var k = 1;
    while (isMonotonic && k < A.length) {
      b = Number(A[k]);
      k++;
      var diff = b - a;
      a = b;
      if (Math.abs(diff) < 0.000001) {
        if (isStrict) {
          isMonotonic = false;
        }
      } else {
        if (typeof order === 'undefined') {
          order = diff < 0 ? -1 : 1;
        } else {
          if (order * (diff < 0 ? -1 : 1) < 0) {
            isMonotonic = false;
          }
        }
      }
    }
    if (typeof order === 'undefined') {
      order = 0;
    }
    return isMonotonic ? order : 0;
  }

  function addRubric(title, criteria, association) {
    var pointsPossible = 0;
    for (var i = 0; i < criteria.length; i++) {
      if (typeof criteria[i].ignore_for_scoring === 'undefined' || !getBoolean(criteria[i].ignore_for_scoring)) {
        pointsPossible += Number(criteria[i].ratings[0].points);
      }
    }
    var F = {
      'rubric' : {
        'title' : title,
        'points_possible' : pointsPossible,
        'free_form_criterion_comments' : 0,
        'criteria' : criteria,
      },
      'rubric_association' : {
        'id' : '',
        'use_for_grading' : 0,
        'hide_score_total' : 0,
        'association_type' : association.type,
        'association_id' : association.id,
        'purpose' : 'bookmark'
      },
      'title' : title,
      'points_possible' : pointsPossible,
      'rubric_id' : 'new',
      'rubric_association_id' : '',
      'skip_updating_points_possible' : 0,
    };
    return F;
  }

  function addCriterion(item) {
    if (typeof item === 'undefined') {
      return false;
    }
    var name = item.name.replace(/\s*\\n\s*/g, ' ').replace(/\s+/g, ' ');
    var longDesc = typeof item.longDesc === 'undefined' ? '' : item.longDesc.replace(/\\n/g, '\n');
    var ratings = addRatings(item.ratings, item.points, item.ratingsDesc);
    var criterion = {
      'description' : name,
      'long_description' : longDesc
    };
    if (ratings !== false) {
      criterion.ratings = ratings;
      criterion.points = ratings[0].points;
    }
    return criterion;
  }

  function addRatings(descriptions, points, ratingsDesc) {
    // Generate the ratings, reversing the order if necessary
    if (descriptions.length === 0 || descriptions.length !== points.length) {
      return false;
    }
    var mono = checkMonotonic(points, false);
    if (mono === 0) {
      return false;
    }
    var ratings = [];
    var n = points.length;
    var j;

    // Handle case when ratingsDesc might not be provided
    ratingsDesc = ratingsDesc || Array(n).fill('');

    // Make sure ratingsDesc is at least as long as descriptions
    while (ratingsDesc.length < descriptions.length) {
      ratingsDesc.push('');
    }

    for (var i = 0; i < n; i++) {
      j = mono < 0 ? i : n - 1 - i;
      var rating = {
        'description' : descriptions[j].replace(/\\n/g, ' ').replace(/\s+/g, ' '),
        'points' : points[j],
      };

      // Add long_description if it exists
      if (ratingsDesc[j] && ratingsDesc[j] !== '') {
        rating.long_description = ratingsDesc[j].replace(/\\n/g, '\n');
      }

      ratings.push(rating);
    }
    return ratings;
  }

  function getCsrfToken() {
    var csrfRegex = new RegExp('^_csrf_token=(.*)$');
    var csrf;
    var cookies = document.cookie.split(';');
    for (var i = 0; i < cookies.length; i++) {
      var cookie = cookies[i].trim();
      var match = csrfRegex.exec(cookie);
      if (match) {
        csrf = decodeURIComponent(match[1]);
        break;
      }
    }
    return csrf;
  }

  function add_button() {
    var parent = document.querySelector('aside#right-side');
    if (parent) {
      var el = parent.querySelector('#jj_rubric');
      if (!el) {
        el = document.createElement('a');
        el.href = '#';
        el.classList.add('btn', 'button-sidebar-wide');
        el.id = 'jj_rubric';
        el.innerHTML = 'âš¡ Import Rubric';
        el.style.cssText = 'margin-bottom: 10px; border: 2px solid #0374B5; transition: background-color 0.2s ease;';

        // Add hover effect
        el.addEventListener('mouseenter', function() {
          this.style.setProperty('background-color', '#e8e8e8', 'important');
        });
        el.addEventListener('mouseleave', function() {
          this.style.setProperty('background-color', '', '');
        });

        el.addEventListener('click', openDialog);
        parent.appendChild(el);
      }
    }
  }

  function createDialog() {
    var el = document.querySelector('#jj_rubric_dialog');
    if (!el) {
      el = document.createElement('div');
      el.id = 'jj_rubric_dialog';
      el.classList.add('ic-Form-control');
      var label = document.createElement('label');
      label.htmlFor = 'jj_rubric_title';
      label.textContent = 'Rubric Title: ';
      label.classList.add('ic-Label');
      el.appendChild(label);
      var input = document.createElement('input');
      input.id = 'jj_rubric_title';
      input.classList.add('ic-Input');
      input.type = 'text';
      input.placeholder = 'Enter name of rubric';
      el.appendChild(input);
      label = document.createElement('label');
      label.htmlFor = 'jj_rubric_text';
      label.textContent = 'Rubric Contents';
      label.classList.add('ic-Label');
      el.appendChild(label);
      var textarea = document.createElement('textarea');
      textarea.id = 'jj_rubric_text';
      textarea.classList.add('ic-Input');
      textarea.placeholder = 'Paste a tab-delimited rubric into this textbox.';
      el.appendChild(textarea);

      // Add format guide div (displayed by default)
      var formatGuideDiv = document.createElement('div');
      formatGuideDiv.id = 'format_guide';
      formatGuideDiv.style.marginTop = '15px';
      formatGuideDiv.style.marginBottom = '15px';
      formatGuideDiv.style.padding = '15px';
      formatGuideDiv.style.border = '1px solid #ccc';
      formatGuideDiv.style.backgroundColor = '#f8f8f8';
      formatGuideDiv.style.borderRadius = '4px';

      var guideHTML = '<h4 style="margin-top:0;">Rubric Format Guide</h4>' +

  '<p style="font-size:16px;"><strong>ðŸ“„ <a href="https://fiudit.sharepoint.com/:x:/s/FIU-Online/LDI/Instructional_Design/ESDIb76RBxVOlGzfQl-7a-gBLX4iG_R78TrU46lT9Dh74g?e=ClyccM" target="_blank" rel="noopener noreferrer">Download Sample Template</a></strong> - Start with our ready-to-use example</p>' +

  '<p><strong>Quick Start:</strong></p>' +
  '<ol>' +
  '<li>Open the template or create your rubric in a spreadsheet</li>' +
  '<li>Copy all cells (Ctrl+C/Cmd+C) - <strong>including or excluding headers</strong></li>' +
  '<li>Paste into the "Rubric Contents" field above (Ctrl+V/Cmd+V)</li>' +
  '<li>Enter a title and click "Create"</li>' +
  '</ol>' +

  '<p><strong>Supported Formats:</strong> The importer automatically detects which format you\'re using.</p>' +
  '<ul style="list-style-type: none; padding-left: 0;">' +
  '<li><strong>Format 1:</strong> Criterion | Rating | Points | Desc | Rating | Points | Desc ...</li>' +
  '<li><strong>Format 2:</strong> Criterion | Long Desc | Rating | Points | Desc | Rating | Points | Desc ...</li>' +
  '<li><strong>Format 3:</strong> Criterion | Rating | Points | Rating | Points ...</li>' +
  '<li><strong>Format 4:</strong> Criterion | Long Desc | Rating | Points | Rating | Points ...</li>' +
  '</ul>' +

  '<p><strong>Header Row:</strong> <em>Optional</em> - The importer will skip rows containing these keywords: <code>criterion</code>, <code>rating</code>, <code>points</code>, <code>description</code>, <code>title</code>, <code>name</code>, <code>long</code> (case-insensitive, 2+ keywords required)</p>' +

  '<p><a href="#" id="show_detailed_guide" style="color:#0066cc;">Show detailed format requirements â–¼</a></p>' +

  '<div id="detailed_guide" style="display:none; margin-top:10px; padding:10px; border:1px solid #ddd; background-color:#fafafa; border-radius:4px;">' +

  '<h5>Important Notes:</h5>' +
  '<ul>' +
  '<li><strong>Headers:</strong> Optional. If included, rows with 2+ of these keywords are auto-skipped: criterion, rating, points, description, title, name, long.</li>' +
  '<li><strong>Long Description (Column 2):</strong> Optional for criterion description. Can be left empty.</li>' +
  '<li><strong>Rating Descriptions:</strong> Optional. Can appear after each rating\'s points or be omitted entirely.</li>' +
  '<li><strong>Points Order:</strong> Should be in descending order (highest to lowest) for each criterion.</li>' +
  '<li><strong>Minimum Requirements:</strong> Each criterion must have at least 2 rating levels with valid point values.</li>' +
  '<li><strong>Format Detection:</strong> The script automatically detects your format by testing all 4 patterns above.</li>' +
  '<li><strong>Blank Lines:</strong> Empty rows are automatically ignored.</li>' +
  '</ul>' +

  '</div>';

      // Add click handler for expandable section
      setTimeout(function() {
        var toggleLink = document.getElementById('show_detailed_guide');
        if (toggleLink) {
          toggleLink.addEventListener('click', function(e) {
            e.preventDefault();
            var detailedGuide = document.getElementById('detailed_guide');
            if (detailedGuide.style.display === 'none') {
              detailedGuide.style.display = 'block';
              this.textContent = 'Hide detailed format requirements â–²';
            } else {
              detailedGuide.style.display = 'none';
              this.textContent = 'Show detailed format requirements â–¼';
            }
          });
        }
      }, 100);

      formatGuideDiv.innerHTML = guideHTML;
      el.appendChild(formatGuideDiv);

      var msg = document.createElement('div');
      msg.id = 'jj_rubric_msg';
      msg.classList.add('ic-flash-warning');
      msg.style.display = 'none';
      msg.style.userSelect = 'text';
      msg.style.cursor = 'text';
      el.appendChild(msg);
      var parent = document.querySelector('body');
      parent.appendChild(el);
    }
  }

  function openDialog() {
    try {
      createDialog();
      $('#jj_rubric_dialog').dialog({
        'title' : 'Import Rubric',
        'autoOpen' : false,
        'buttons' : [ {
          'text' : 'Create',
          'click' : processDialog
        }, {
          'text' : 'Cancel',
          'click' : function() {
            $(this).dialog('close');
            var el = document.getElementById('jj_rubric_text');
            if (el) {
              el.value = '';
            }
            errors = [];
            updateMsgs();
          }
        } ],
        'modal' : true,
        'height' : 'auto',
        'width' : '80%'
      });
      if (!$('#jj_rubric_dialog').dialog('isOpen')) {
        $('#jj_rubric_dialog').dialog('open');
      }
    } catch (e) {
      console.log(e);
    }
  }

  function processDialog() {
    // Reset global variable errors
    errors = [];
    var title, txt, assocMatch, association;
    var el = document.getElementById('jj_rubric_title');
    if (el.value && el.value.trim() !== '') {
      title = el.value;
      rubricTitle = title;
    } else {
      errors.push('You must provide a title for your rubric.');
    }
    el = document.getElementById('jj_rubric_text');
    if (el.value && el.value.trim() !== '') {
      txt = el.value;
    } else {
      errors.push('You must paste your rubric into the textbox.');
    }
    assocMatch = assocRegex.exec(window.location.pathname);
    if (assocMatch) {
      var associationType = assocMatch[1].charAt(0).toUpperCase() + assocMatch[1].slice(1);
      association = {
        'type' : associationType,
        'id' : assocMatch[2],
      };
      rubricAssociation = association;
    } else {
      errors.push('Unable to determine where to place this rubric.');
    }
    if (errors.length === 0) {
      criteria = blockRubric(txt) || flexRubricWithDesc(txt);
      if (typeof criteria === 'object' && criteria.length > 0) {
        prepareRubric(title, criteria, association);
      }
    }
    updateMsgs();
  }

  function prepareRubric(title, criteria, association) {
    if (typeof criteria === 'object' && criteria.length > 0) {
      var formData = addRubric(title, criteria, association);
      if (typeof formData !== 'undefined') {
        saveRubric(formData);
      }
    }
  }

  function saveRubric(formData) {
    formData.authenticity_token = getCsrfToken();
    var url = window.location.pathname;
    $.ajax({
      'cache' : false,
      'url' : url,
      'type' : 'POST',
      'data' : formData,
    }).done(function() {
      updateMsgs();
      $('#jj_rubric_dialog').dialog('close');
      window.location.reload(true);
    }).fail(function() {
      errors.push('All the information was supplied correctly, but there was an error saving rubric to Canvas.');
      updateMsgs();
    });
  }

  function updateMsgs() {
    var msg = document.getElementById('jj_rubric_msg');
    if (!msg) {
      return;
    }
    if (msg.hasChildNodes()) {
      msg.removeChild(msg.childNodes[0]);
    }
    if (typeof errors === 'undefined' || errors.length === 0) {
      msg.style.display = 'none';
    } else {
      var ul = document.createElement('ul');
      ul.style.userSelect = 'text';
      ul.style.cursor = 'text';
      var li;
      for (var i = 0; i < errors.length; i++) {
        li = document.createElement('li');
        li.style.userSelect = 'text';
        li.style.cursor = 'text';
        li.textContent = errors[i];
        ul.appendChild(li);
      }
      msg.appendChild(ul);
      msg.style.display = 'inline-block';
    }
  }

  function blockRubric(txt) {
    var criteria = [];
    var isValid = true;
    var isMethod = false;
    try {
      var dequoted = dequote(txt);
      var lines = dequoted.split(/\r?\n/);
      var block = false;
      var newblock;
      var i = 0;
      while (isValid && i < lines.length) {
        var words = lines[i].replace(/[\s\uFEFF\xA0]+$/, '').split(/\t/);
        i++;
        words.map(function(s) {
          return s.trim();
        });
        if (words.length === 1 && words[0] === '') {
          // Ignore blank lines
          continue;
        }
        var name = '';
        var longDesc = '';
        var descriptions = [];
        var points = [];
        if (words.length < 3) {
          continue;
        } else {
          newblock = checkPointsRow(words);
          if (newblock !== false) {
            // We have a valid numeric line, start using this from now on.
            block = newblock;
            continue;
          }
        }
        if (block === false) {
          // This is not a row that is all numbers
          if (i > 1) {
            // Must find a points row within the first two rows
            isValid = false;
          }
          continue;
        } else {
          isMethod = true;
        }
        if (isValid) {
          name = words[0];
          longDesc = block.start > 1 ? words[1] : '';
          var j = block.start;
          var endAt = words.length < 1 + block.end ? words.length : 1 + block.end;
          var k = 0;
          while (j < endAt) {
            var rating = words[j];
            var point = block.points[k];
            j++;
            k++;
            if (rating !== '') {
              descriptions.push(rating);
              points.push(point);
            }
          }
          if (descriptions.length === 1) {
            errors.push('Only one rating found in line ' + i);
            isValid = false;
          }
        }
        if (isValid) {
          var item = {
            'name' : name,
            'longDesc' : longDesc,
            'outcome' : false,
            'ratings' : descriptions,
            'points' : points
          };
          var criterion = addCriterion(item);
          if (criterion !== false) {
            criteria.push(criterion);
          } else {
            errors.push('Unable to create criterion for line ' + i);
            isValid = false;
          }
        }
      }
    } catch (e) {
      console.log(e);
    }
    return isValid && criteria.length > 0 ? criteria : isMethod;
  }

  // New helper function to detect if a row looks like a header
  function isHeaderRow(words) {
    var headerKeywords = ['criterion', 'rating', 'points', 'description', 'title', 'name', 'long'];
    var lowerWords = words.map(function(w) { return w.toLowerCase(); });

    var headerCount = 0;
    for (var i = 0; i < lowerWords.length && i < 10; i++) {
      for (var j = 0; j < headerKeywords.length; j++) {
        if (lowerWords[i].indexOf(headerKeywords[j]) !== -1) {
          headerCount++;
          break;
        }
      }
    }

    return headerCount >= 2;
  }

  function flexRubricWithDesc(txt) {
    var criteria = [];
    var isValid = true;
    try {
      var dequoted = dequote(txt);
      var lines = dequoted.split(/\r?\n/);
      var i = 0;
      var actualLineNumber = 0;

      while (isValid && i < lines.length) {
        var words = lines[i].trim().split(/\t/);
        i++;
        actualLineNumber++;

        if (words.length === 1 && words[0] === '') {
          continue;
        }

        words = words.map(function(s) {
          return s.trim();
        });

        // Skip header rows
        if (isHeaderRow(words)) {
          console.log('Skipping detected header row at line ' + actualLineNumber);
          continue;
        }

        var name = '';
        var longDesc = '';
        var descriptions = [];
        var points = [];
        var ratingsDesc = [];
        var validLine = true;
        var k = 0;

        // Get criterion name
        if (words.length > k) {
          name = words[k++];
        }

        // Try to detect format by analyzing the pattern
        // Count potential rating-point pairs starting from different positions
        var format = detectFormat(words, k);

        if (format.hasLongDesc) {
          longDesc = words[k++];
        }

        // Process ratings based on detected format
        while (isValid && validLine && k < words.length) {
          // Need at least rating and points
          if (k + 1 >= words.length) {
            break;
          }

          var ratingTitle = words[k];
          var ratingPoints = words[k + 1];

          // Skip empty pairs
          if (ratingTitle === '' && ratingPoints === '') {
            k += 2;
            if (format.hasRatingDesc && k < words.length) {
              k++; // Skip the description column too
            }
            continue;
          }

          // Validate rating title
          if (ratingTitle === '') {
            if (descriptions.length > 0) {
              errors.push('ERROR: Empty rating name at line ' + actualLineNumber + ', column ' + (k + 1));
              isValid = false;
            }
            validLine = false;
            break;
          }

          // Validate points
          if (!isPoints(ratingPoints)) {
            if (descriptions.length > 0) {
              errors.push('ERROR: Expected points at line ' + actualLineNumber + ', column ' + (k + 2) + '. Found: "' + ratingPoints + '"');
              isValid = false;
            }
            validLine = false;
            break;
          }

          // Valid pair found
          descriptions.push(ratingTitle);
          points.push(ratingPoints);
          k += 2;

          // Handle rating description if format includes it
          var ratingDesc = '';
          if (format.hasRatingDesc && k < words.length) {
            ratingDesc = words[k++];
          }
          ratingsDesc.push(ratingDesc);
        }

        if (isValid && validLine && descriptions.length > 0) {
          if (descriptions.length < 2) {
            errors.push('Each criterion must have at least 2 ratings. Line ' + actualLineNumber + ' only has ' + descriptions.length + ' rating(s).');
            isValid = false;
          } else {
            var item = {
              'name' : name,
              'longDesc' : longDesc,
              'outcome' : false,
              'ratings' : descriptions,
              'points' : points,
              'ratingsDesc': ratingsDesc
            };
            var criterion = addCriterion(item);
            if (criterion !== false) {
              criteria.push(criterion);
            } else {
              errors.push('Unable to create criterion for line ' + actualLineNumber);
              isValid = false;
            }
          }
        }
      }
    } catch (e) {
      console.log(e);
      errors.push('Error parsing rubric data: ' + e.message);
      isValid = false;
    }
    return isValid ? criteria : false;
  }

  function detectFormat(words, startPos) {
    // Analyze the structure to determine if we have:
    // - Long description in column 2
    // - Rating descriptions between rating pairs

    var result = {
      hasLongDesc: false,
      hasRatingDesc: false
    };

    if (startPos >= words.length) {
      return result;
    }

    // Test pattern 1: No long desc, with rating desc (Rating|Pts|Desc|Rating|Pts|Desc)
    var pattern1Valid = true;
    var pattern1Pairs = 0;
    var pos1 = startPos;
    while (pos1 + 2 < words.length && pattern1Valid && pattern1Pairs < 10) {
      // Allow empty cells but count non-empty valid pairs
      if (words[pos1] === '' && words[pos1 + 1] === '') {
        pos1 += 3;
        continue;
      }
      if (words[pos1] !== '' && isPoints(words[pos1 + 1])) {
        pattern1Pairs++;
        pos1 += 3; // Skip rating, points, and description
      } else {
        pattern1Valid = false;
      }
    }

    // Test pattern 2: Long desc, with rating desc (LongDesc|Rating|Pts|Desc|Rating|Pts|Desc)
    var pattern2Valid = true;
    var pattern2Pairs = 0;
    var pos2 = startPos + 1;
    while (pos2 + 2 < words.length && pattern2Valid && pattern2Pairs < 10) {
      if (words[pos2] === '' && words[pos2 + 1] === '') {
        pos2 += 3;
        continue;
      }
      if (words[pos2] !== '' && isPoints(words[pos2 + 1])) {
        pattern2Pairs++;
        pos2 += 3;
      } else {
        pattern2Valid = false;
      }
    }

    // Test pattern 3: No long desc, no rating desc (Rating|Pts|Rating|Pts)
    var pattern3Valid = true;
    var pattern3Pairs = 0;
    var pos3 = startPos;
    while (pos3 + 1 < words.length && pattern3Valid && pattern3Pairs < 10) {
      if (words[pos3] === '' && words[pos3 + 1] === '') {
        pos3 += 2;
        continue;
      }
      if (words[pos3] !== '' && isPoints(words[pos3 + 1])) {
        pattern3Pairs++;
        pos3 += 2;
      } else {
        pattern3Valid = false;
      }
    }

    // Test pattern 4: Long desc, no rating desc (LongDesc|Rating|Pts|Rating|Pts)
    var pattern4Valid = true;
    var pattern4Pairs = 0;
    var pos4 = startPos + 1;
    while (pos4 + 1 < words.length && pattern4Valid && pattern4Pairs < 10) {
      if (words[pos4] === '' && words[pos4 + 1] === '') {
        pos4 += 2;
        continue;
      }
      if (words[pos4] !== '' && isPoints(words[pos4 + 1])) {
        pattern4Pairs++;
        pos4 += 2;
      } else {
        pattern4Valid = false;
      }
    }

    // Choose the pattern with the most valid pairs
    var maxPairs = Math.max(pattern1Pairs, pattern2Pairs, pattern3Pairs, pattern4Pairs);

    if (maxPairs >= 2) {
      if (pattern2Pairs === maxPairs) {
        result.hasLongDesc = true;
        result.hasRatingDesc = true;
      } else if (pattern1Pairs === maxPairs) {
        result.hasLongDesc = false;
        result.hasRatingDesc = true;
      } else if (pattern4Pairs === maxPairs) {
        result.hasLongDesc = true;
        result.hasRatingDesc = false;
      } else if (pattern3Pairs === maxPairs) {
        result.hasLongDesc = false;
        result.hasRatingDesc = false;
      }
    }

    return result;
  }

  function isInteger(t) {
    if (typeof t === 'undefined') {
      return false;
    }
    return /^[0-9]+$/.test(t.trim());
  }

  function isBoolean(t, req) {
    if (typeof t === 'undefined') {
      return false;
    }
    if (typeof req !== 'undefined' && req && t === '') {
      return false;
    }
    return /^$|^[01]$/.test(t.trim());
  }

  function getBoolean(t) {
    return (t === false || t === null || t === '' || t === 0 || t === '0') ? false : true;
  }

  function isPoints(t) {
    if (typeof t === 'undefined') {
      return false;
    }
    return /^([0-9]+|[0-9]+[.][0-9]+|0?[.][0-9]+)$/.test(t.trim());
  }

  function dequote(t) {
    if (typeof t === 'undefined') {
      return '';
    }
    return t.replace(/^"(.*)"$/g, '$1').replace(/""/g, '"');
  }

})();
